/**********************************************************************
Copyright ©2015 Advanced Micro Devices, Inc. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

•   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
•   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
********************************************************************/

#version 430
layout( local_size_x = 64, local_size_y = 1, local_size_z = 1 ) in;

struct bbox
{
	vec3 pmin;
	vec3 pmax;
};

struct HlbvhNode
{
		int parent;
		int left;
		int right;
		int next;
};

layout( std140, binding = 0 ) buffer restrict readonly MortoncodesBlock
{
	int Mortoncodes[];
};

layout( std140, binding = 1 ) buffer restrict readonly BoundsBlock
{
	bbox Bounds[];
};

layout( std140, binding = 2 ) buffer restrict readonly IndicesBlock
{
	int Indices[];
};

layout( std140, binding = 3 ) buffer restrict readonly NumprimsBlock
{
	int Numprims[];
};

layout( std430, binding = 4 ) buffer NodesBlock
{
	HlbvhNode Nodes[];
};

layout( std430, binding = 5 ) buffer BoundssortedBlock
{
	bbox Boundssorted[];
};

#define LEAFIDX(i) ((Numprims-1) + i)
#define NODEIDX(i) (i)

void main()
{
	uint globalID = gl_GlobalInvocationID.x;

	// Set child
	if (globalID < Numprims)
	{
		nodes[LEAFIDX(globalID)].left = nodes[LEAFIDX(globalID)].right = indices[globalID];
		boundssorted[LEAFIDX(globalID)] = bounds[indices[globalID]];
	}
	
	// Set internal nodes
	if (globalID < Numprims - 1)
	{
		// Find span occupied by the current node
		int2 range = FindSpan(mortoncodes, numprims, globalID);

		// Find split position inside the range
		int  split = FindSplit(mortoncodes, numprims, range);

		// Create child nodes if needed
		int c1idx = (split == range.x) ? LEAFIDX(split) : NODEIDX(split);
		int c2idx = (split + 1 == range.y) ? LEAFIDX(split + 1) : NODEIDX(split + 1);

		nodes[NODEIDX(globalID)].left = c1idx;
		nodes[NODEIDX(globalID)].right = c2idx;
		//nodes[NODEIDX(globalID)].next = (range.y + 1 < Numprims) ? range.y + 1 : -1;
		nodes[c1idx].parent = NODEIDX(globalID);
		//nodes[c1idx].next = c2idx;
		nodes[c2idx].parent = NODEIDX(globalID);
		//nodes[c2idx].next = nodes[NODEIDX(globalID)].next;
	}
}

// Calculates longest common prefix length of bit representations
// if  representations are equal we consider sucessive indices
int delta( in int inNumprims, in int i1, in int i2)
{
	// Select left end
	int left = min(i1, i2);
	// Select right end
	int right = max(i1, i2);
	// This is to ensure the node breaks if the index is out of bounds
	if (left < 0 || right >= inNumprims) 
	{
		return -1;
	}
	// Fetch Morton codes for both ends
	int leftcode = Mortoncodes[left];
	int rightcode = Mortoncodes[right];

	// Special handling of duplicated codes: use their indices as a fallback
	return leftcode != rightcode ? clz(leftcode ^ rightcode) : (32 + clz(left ^ right));
}

// Shortcut for delta evaluation
#define DELTA(i,j) delta(mortoncodes,numprims,i,j)

// Find span occupied by internal node with index idx
int2 FindSpan(__global int* mortoncodes, int numprims, int idx)
{
	// Find the direction of the range
	int d = sign((float)(DELTA(idx, idx+1) - DELTA(idx, idx-1)));

	// Find minimum number of bits for the break on the other side
	int deltamin = DELTA(idx, idx-d);

	// Search conservative far end
	int lmax = 2;
	while (DELTA(idx,idx + lmax * d) > deltamin)
		lmax *= 2;

	// Search back to find exact bound
	// with binary search
	int l = 0;
	int t = lmax;
	do
	{
		t /= 2;
		if(DELTA(idx, idx + (l + t)*d) > deltamin)
		{
			l = l + t;
		}
	}
	while (t > 1);

	// Pack span 
	int2 span;
	span.x = min(idx, idx + l*d);
	span.y = max(idx, idx + l*d);
	return span;
}

// Find split idx within the span
int FindSplit(__global int* mortoncodes, int numprims, int2 span)
{
	// Fetch codes for both ends
	int left = span.x;
	int right = span.y;

	// Calculate the number of identical bits from higher end
	int numidentical = DELTA(left, right);

	do
	{
		// Proposed split
		int newsplit = (right + left) / 2;

		// If it has more equal leading bits than left and right accept it
		if (DELTA(left, newsplit) > numidentical)
		{
			left = newsplit;
		}
		else
		{
			right = newsplit;
		}
	}
	while (right > left + 1);

	return left;
}

// Set parent-child relationship
__kernel void BuildHierarchy(
	// Sorted Morton codes of the primitives
	__global int* mortoncodes,
	// Bounds
	__global bbox* bounds,
	// Primitive indices
	__global int* indices,
	// Number of primitives
	int numprims,
	// Nodes
	__global HlbvhNode* nodes,
	// Leaf bounds
	__global bbox* boundssorted
	)
{
	int globalid = get_global_id(0);

	// Set child
	if (globalid < numprims)
	{
		nodes[LEAFIDX(globalid)].left = nodes[LEAFIDX(globalid)].right = indices[globalid];
		boundssorted[LEAFIDX(globalid)] = bounds[indices[globalid]];
	}
	
	// Set internal nodes
	if (globalid < numprims - 1)
	{
		// Find span occupied by the current node
		int2 range = FindSpan(mortoncodes, numprims, globalid);

		// Find split position inside the range
		int  split = FindSplit(mortoncodes, numprims, range);

		// Create child nodes if needed
		int c1idx = (split == range.x) ? LEAFIDX(split) : NODEIDX(split);
		int c2idx = (split + 1 == range.y) ? LEAFIDX(split + 1) : NODEIDX(split + 1);

		nodes[NODEIDX(globalid)].left = c1idx;
		nodes[NODEIDX(globalid)].right = c2idx;
		//nodes[NODEIDX(globalid)].next = (range.y + 1 < numprims) ? range.y + 1 : -1;
		nodes[c1idx].parent = NODEIDX(globalid);
		//nodes[c1idx].next = c2idx;
		nodes[c2idx].parent = NODEIDX(globalid);
		//nodes[c2idx].next = nodes[NODEIDX(globalid)].next;
	}
}

// Propagate bounds up to the root
__kernel void RefitBounds(__global bbox* bounds,
						  int numprims,
						  __global HlbvhNode* nodes,
						  __global int* flags
						  )
{
	int globalid = get_global_id(0);

	// Start from leaf nodes
	if (globalid < numprims)
	{
		// Get my leaf index
		int idx = LEAFIDX(globalid);

		do
		{
			// Move to parent node
			idx = nodes[idx].parent;

			// Check node's flag
			if (atomic_cmpxchg(flags + idx, 0, 1) == 1)
			{
				// If the flag was 1 the second child is ready and 
				// this thread calculates bbox for the node

				// Fetch kids
				int lc = nodes[idx].left;
				int rc = nodes[idx].right;

				// Calculate bounds
				bbox b = bboxunion(bounds[lc], bounds[rc]);

				// Write bounds
				bounds[idx] = b;
			}
			else
			{
				// If the flag was 0 set it to 1 and bail out.
				// The thread handling the second child will
				// handle this node.
				break;
			}
		}
		while (idx != 0);
	}
}